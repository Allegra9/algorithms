<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<!-- <meta name="viewport" content="width=device-width, initial-scale=1"> -->

<title>Algorithms</title>
    
<!--Google Fonts-->
<link href="https://fonts.googleapis.com/css?family=Allura" rel="stylesheet">
    
<!--Style sheet -->
<link href="style.css" rel="stylesheet" type="text/css">
    
<!--1.LINK FOR BOOTSTRAP--> 
<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0-alpha.6/css/bootstrap.min.css" integrity="sha384-rwoIResjU2yc3z8GV/NPeZWAv56rSmLldC3R/AZzGRnGxQQKnKkoFVhFQhNUwEyJ" crossorigin="anonymous">
    
<!--2.LINK FOR ICONS-->   
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
    
</head>
<body>

<div class="container">

<h3 class="text-center">Algorithms</h3>

<p><b>Map</b> works by taking a list and a function, and it applies the function to each element in the list and returns a new list. For example, you may want to square every number in an array or append a string to every element in an array. We want an implementation where we can pass in two parameters, one being the array and the second being some function that will be mapped onto every element.</p>
<p><b>Filter</b> works by taking a list and a conditional statement, and it returns a new list where every element in the original list passes the conditional (returns true). For example, you may have a list of ages and you want a new list of ages where each one is between 21 and 35. We want an implementation where, similar to the map function, we pass in a list and a function that contains within it a conditional statement.</p>


<figure>
	<figurecaption><h5>Map example:</h5></figurecaption>
	<pre>
		<code>
function map(arr, fn) { 
  let result = [];

// apply the function to each element and store the result
  for (let i of arr) { 
    let applied = fn(i); 
    result.push(applied);
  }
  return result; 
}

let square = (x) => x * x;
let addZeros = (x) => parseInt(x += '00');

map([1, 2, 3, 4], square);    // [1, 4, 9, 16]
map([1, 2, 3, 4], addZeros);   // [100, 200, 300, 400]
		</code>
	</pre>
	<br>


<figure>
	<figurecaption><h5>Filter example:</h5></figurecaption>
	<pre>
		<code>
function filter(arr, fn) { 
  let result = [];

// pass the element to the function and check 
// if the result comes back true
  for (let i of arr) {
	let check = fn(i);
	if (check) { 
	  result.push(i); 
	} 
  }
return result; 
}

let isPositive = (x) => x > 0;

filter([-2, 4, 5, 8, -44, -6], isPositive);   // [4, 5, 8]
		</code>
	</pre>
	<br>


	<figure>
	<figurecaption><h5>Filter arr to meet the func condition:</h5></figurecaption>
	<pre>
		<code>
function findElement(arr, func) {
  var num = 0;

var result = arr.filter(func);
  return result;
}

console.log(findElement([1, 2, 3, 4], function(num){ return num % 2 === 0; }));  //[2, 4]
		</code>
	</pre>
	<br>


	<figure>
	<figurecaption><h5>Drop elements from an arr until they meet the func condition:</h5></figurecaption>
	<pre>
		<code>
function dropElements(arr, func) {
  
  var times = arr.length;

 for (var i = 0; i < times; i++) {
    if (func(arr[0])) {
      break;
    } else {
      arr.shift();
    }
  }
  return arr;
}

console.log(dropElements([1, 2, 3, 4], function(n) {return n >= 4; }));  //4
		</code>
	</pre>
	<br>





<h4>FREECODECAMP "BASIC":</h4>
<br>

<figure>
	<figurecaption><h5>Reverse a string:</h5></figurecaption>
	<pre>
		<code>
function reverseString(str) {
  return str.split('').reverse().join('');
}

reverseString("hello");  //"olleh"
reverseString("Howdy");  //"ydwoH"
reverseString("Greetings from Earth");  
//"htraE morf sgniteerG"
		</code>
	</pre>
	<br>


	<figurecaption><h5>Factorialize a number:</h5>
		<p>Return the factorial of the provided integer. If the integer is represented with the letter n, a factorial is the product of all positive integers less than or equal to n. Factorials are often represented with the shorthand notation n! 
	For example: 5! = 1 * 2 * 3 * 4 * 5 = 120</p>
	</figurecaption>
	<pre>
		<code>
function factorialize(num) { 
	for (a = 1; num >= 1; num--) { 
	a = num * a; 
 } 
	return a; 
} 

factorialize(5);  // 120
factorialize(10);  // 3628800
factorialize(0);  // 1
factorialize(20); // 2432902008176640000
		</code>
	</pre>
	<br>

		<figurecaption><h5>+ solution</h5>
	</figurecaption>
	<pre>
		<code>
function FirstFactorial(num) { 

  var factorial = 1;

  for (var i = 1; i <= num; i++) {  
    // multiply each number between 1 and num  
    // factorial = 1 * 1 = 1
    // factorial = 1 * 2 = 2
    // factorial = 2 * 3 = 6
    // factorial = 6 * 4 = 24
    // ...
    factorial = factorial * i;
  }
  return factorial;  
}
   
console.log(FirstFactorial(5)); //5*4*3*2*1 = 120
		</code>
	</pre>
	<br>


	<figurecaption><h5>Check for Palindromes:</h5>
		<p>Return true if the given string is a palindrome. Otherwise, return false. A palindrome is a word or sentence that's spelled the same way both forward and backward, ignoring punctuation, case, and spacing.</p><p><b>Note:</b><br>You'll need to remove all non-alphanumeric characters (punctuation, spaces and symbols) and turn everything lower case in order to check for palindromes. We'll pass strings with varying formats, such as "racecar", "RaceCar", and "race CAR" among others. We'll also pass strings with special symbols, such as "2A3*3a2", "2A3 3a2", and "2_A3*3#A2"</p>
	</figurecaption>
	<pre>
		<code>
function palindrome(str) {

  return str.replace(/[\W_]/g, '').toLowerCase() ===
         str.replace(/[\W_]/g, '').toLowerCase().split('').reverse().join('');
}

palindrome("eye"); //true
palindrome("_eye"); //true
palindrome("race car"); //true
palindrome("A man, a plan, a canal. Panama"); //true
palindrome("nope"); //false
palindrome("five|\_/|four");  //false
palindrome("0_0 (: /-\ :) 0-0");  //true
palindrome("My age is 0, 0 si ega ym.");  //true
		</code>
	</pre>
	<br>


	<figurecaption><h5>Find the Longest Word in a String:</h5>
		<p>Return the length of the longest word in the provided sentence. Your response should be a number.</p>
	</figurecaption>
	<pre>
		<code>
function findLongestWord(str) {
    var splits = str.split(" "); //this makes an array
    var maxLength = 0;
    
    for (var i = 0; i < splits.length; i++) {
        if (splits[i].length > maxLength) {
            maxLength = splits[i].length;
        }
    }
    return maxLength;
}

findLongestWord("The quick brown fox jumped over the lazy dog"); //6
findLongestWord("What if we try a super-long word such as otorhinolaryngology"); //19
		</code>
	</pre>
	<br>


	<p><b>+</b> Using <b>.reduce()</b></p>
	</figurecaption>
	<pre>
		<code>
function findLongestWord(s) {
  return s.split(' ')
    .reduce(function(x, y) {
      return Math.max(x, y.length)
    }, 0);
}

findLongestWord("The quick brown fox jumped over the lazy dog"); //6
findLongestWord("What if we try a super-long word such as otorhinolaryngology"); //19
		</code>
	</pre>
	<br>


	<figurecaption><h5>Title Case a Sentence:</h5>
		<p>Return the provided string with the first letter of each word capitalized. Make sure the rest of the word is in lower case. For the purpose of this exercise, you should also capitalize connecting words like "the" and "of".</p>
	</figurecaption>
	<pre>
		<code>
function titleCase(str) {
  str = str.toLowerCase();
  
  str = str.split(' ');
  
  for (var i = 0; i < str.length; i++) {
    str[i] = str[i].charAt(0).toUpperCase() + str[i].slice(1); 
  }
  return str.join(" ");
}

titleCase("I'm a little tea pot");  //"I'm A Little Tea Pot"
titleCase("sHoRt AnD sToUt");  //"Short And Stout"
titleCase("HERE IS MY HANDLE HERE IS MY SPOUT"); //"Here Is My Handle Here Is My Spout"
		</code>
	</pre>
	<br>


	<p><b>+ solution:</b></p>
	<pre>
		<code>
function titleCase(str) {
  return str.toLowerCase().replace(/(^|\s)\S/g, (L) => L.toUpperCase());
}

titleCase("I'm a little tea pot");  //"I'm A Little Tea Pot"
titleCase("sHoRt AnD sToUt");  //"Short And Stout"
titleCase("HERE IS MY HANDLE HERE IS MY SPOUT"); //"Here Is My Handle Here Is My Spout"
		</code>
	</pre>
	<p><b>Code Explanation: </b>The solution works by first lowercasing all the characters in the string and then only uppercasing the first character of each word.
	  <ul>
		<li>Lowercase the whole string using str.toLowerCase().</li>
		<li>Replace every word’s first character to uppercase using .replace.</li>
		<li>Search for character at the beginning of each word i.e. matching any character following a space or matching the first character of the whole string, by using the following pattern.</li>
		<br>
		<b>Regex explanation: </b><br>
		<li>Find all non-whitespace characters (\S)</li>
		<li>At the beginning of string (^)</li>
		<li>Or after any whitespace character (\s)</li>
		<li>The g modifier searches for other such word pattern in the whole string and replaces them.</li>
	  </ul>
	</p>
	<br>


	<figurecaption><h5>Return Largest Numbers in Arrays:</h5>
		<p>Return an array consisting of the largest number from each provided sub-array. For simplicity, the provided array will contain exactly 4 sub-arrays. Remember, you can iterate through an array with a simple for loop, and access each member with array syntax arr[i].</p>
	</figurecaption>
	<pre>
		<code>
function largestOfFour(arr) {
   var newArr = [];
    
  for (var i = 0; i < arr.length; i++) {
		var maximum = -Infinity;
      for (var m = 0; m < arr[i].length; m++)
        if (arr[i][m] > maximum)
            maximum = arr[i][m];
      newArr.push(maximum);
  }
  return newArr;
}

largestOfFour([[4, 5, 1, 3], [13, 27, 18, 26], [32, 35, 37, 39], [1000, 1001, 857, 1]]);
//[5, 27, 39, 1001]
		</code>
	</pre>
	<br>


	<p><b>+ solution:</b></p>
	<pre>
		<code>
function largestOfFour(arr) {
  return arr.map(function(group){
    return group.reduce(function(prev, current) {
      return (current > prev) ? current : prev;
    });
  });
}

largestOfFour([[4, 5, 1, 3], [13, 27, 18, 26], [32, 35, 37, 39], [1000, 1001, 857, 1]]);  
//[5, 27, 39, 1001]
		</code>
	</pre>
	<p><b>Code Explanation: </b>
	  <ul>
		<li>We map all items within the main array to a new array using Array.prototype.map() and return this array as the final result.</li>
		<li>Within each inner array, we reduce its contents down to a single value using Array.prototype.reduce()</li>
		<li>The callback function passed to the reduce method takes the previous value and the current value and compares the two values</li>
		<li>If the current value is higher than the previous value we set it as the new previous value for comparison with the next item within the array or returns it to the map method callback if it’s the last item.</li>
	  </ul>
	</p>
	<br>


	<figurecaption><h5>Confirm the Ending:</h5>
		<p>Check if a string (first argument, str) ends with the given target string (second argument, target). <br>This challenge can be solved with the .endsWith() method, which was introduced in ES2015. But for the purpose of this challenge, we would like you to use one of the JavaScript substring methods instead.</p>
	</figurecaption>
	<pre>
		<code>
function confirmEnding(str, target) {
 
  newStr = str.substr(-target.length);
  
  return target === newStr;
}

confirmEnding("Bastian", "n");  //true
confirmEnding("He has to give me a new name", "name");  //true
confirmEnding("Open sesame", "same");  //true
confirmEnding("Open sesame", "pen");  //false
		</code>
	</pre>
	<br>


	<figurecaption><h5>Repeat a string repeat a string:</h5>
		<p>Repeat a given string (first argument) num times (second argument). Return an empty string if num is not a positive number.</p>
	</figurecaption>
	<pre>
		<code>
function repeatStringNumTimes(str, num) {
  if (num < 0) {
        return "";
    }
  return str.repeat(num);
}

repeatStringNumTimes("abc", 3);  //abcabcabc
repeatStringNumTimes("*", 8);  //********
repeatStringNumTimes("abc", -2);  //""
		</code>
	</pre>
	<br>


	<figurecaption><h5>Truncate a string:</h5>
		<p>Truncate a string (first argument) if it is longer than the given maximum string length (second argument). Return the truncated string with a ... ending. <br>Note that inserting the three dots to the end will add to the string length. <br>However, if the given maximum string length num is less than or equal to 3, then the addition of the three dots does not add to the string length in determining the truncated string.</p>
	</figurecaption>
	<pre>
		<code>
function truncateString(str, num) {

  if (str.length > num && num > 3) {
    return str.slice(0, (num - 3)) + '...';
  } else if (str.length > num && num <= 3) {
    return str.slice(0, num) + '...';
  } else {
    return str;
  }
}

truncateString("A-tisket a-tasket A green and yellow basket", 11); //"A-tisket..."
truncateString("Absolutely Longer", 2);  //"Ab..."
truncateString("A-", 1);  //"A..."
truncateString("Peter Piper picked a peck of pickled peppers", 14);  //"Peter Piper..."
		</code>
	</pre>
	<br>


	<p><b>+ ternary solution:</b></p>
	<pre>
		<code>
function truncateString(str, num) {
  if (str.length > num)
    return str.slice(0, num > 3 ? num-3 : num) + '...';
  return str;
}

truncateString("Absolutely Longer", 2);  //"Ab..."
truncateString("A-", 1);  //"A..."
		</code>
	</pre>
	<p><b>Code Explanation: </b><br>In order to understand the above code, you need to understand how a Ternary Operator works. The Ternary Operator is frequently used as a shortcut for the if statement and follows this format:<br><b>condition ? expr1 : expr2</b><br>If the condition evaluates to true, the operator returns the value of expr1. Otherwise, it returns the value of expr2.
	</p>
	<br>


	<figurecaption><h5>Chunky Monkey:</h5>
		<p>Write a function that splits an array (first argument) into groups the length of size (second argument) and returns them as a two-dimensional array.</p>
	</figurecaption>
	<pre>
		<code>
function chunkArrayInGroups(arr, size) {
  var newArr = [];
  var i = 0;

  while (i < arr.length) {
    newArr.push(arr.slice(i, i+size));
    i += size;
  }
  return newArr;
}
console.log(chunkArrayInGroups(["a", "b", "c", "d"], 2));  //["a", "b"]["c", "d"]
chunkArrayInGroups([0, 1, 2, 3, 4, 5, 6], 3);  //[0, 1, 2][3, 4, 5][6]
		</code>
	</pre>
	<br>


	<figurecaption><h5>Slasher Flick:</h5>
		<p>Return the remaining elements of an array after chopping off n elements from the beginning of the array, or the zeroth index.</p>
	</figurecaption>
	<pre>
		<code>
function slasher(arr, howMany) {
  
    arr.splice(0,howMany);
  
  return arr;
}

slasher([1, 2, 3], 2);  //[3]
slasher([1, 2, 3], 9); //[]
slasher(["burgers", "fries", "shake"], 1);  //["fries", "shake"]
		</code>
	</pre>
	<br>


	<figurecaption><h5>Slasher Flick:</h5>
		<p>Return the remaining elements of an array after chopping off n elements from the beginning of the array, or the zeroth index.</p>
	</figurecaption>
	<pre>
		<code>
function slasher(arr, howMany) {
    arr.splice(0,howMany);
  return arr;
}

OR:

function slasher(arr, howMany) {
    return arr.slice(howMany);
}

slasher([1, 2, 3], 2);  //[3]
slasher([1, 2, 3], 9); //[]
slasher(["burgers", "fries", "shake"], 1);  //["fries", "shake"]
		</code>
	</pre>
	<br>


	<figurecaption><h5>Mutations:</h5>
		<p>Return true if the string in the first element of the array contains all of the letters of the string in the second element of the array.<br>For example, ["hello", "Hello"], should return true because all of the letters in the second string are present in the first, ignoring case.<br>The arguments ["hello", "hey"] should return false because the string "hello" does not contain a "y".<br>Lastly, ["Alien", "line"], should return true because all of the letters in "line" are present in "Alien".</p>
	</figurecaption>
	<pre>
		<code>
function mutation(arr) {
  var test = arr[1].toLowerCase();
  var target = arr[0].toLowerCase();
  for (i=0; i < test.length;i++) {
    if (target.indexOf(test[i]) === -1)
      return false;
  }
  return true;
 }

mutation(["zyxwvutsrqponmlkjihgfedcba", "qrstu"]);  //true
mutation(["Mary", "Army"]);  //true
mutation(["Mary", "Aarmy"]);  //true
mutation(["hello", "neo"]);  //false
		</code>
	</pre>
	<p><b>Code Explanation: </b><br>First we make the two strings in the array lowercase. Test will hold what we are looking for in target. Then we loop through our test characters and if any of them is not found we return false. If they are all found, the loop will finish without returning anything and we get to return true.
	</p>
	<br>


	<p><b>+ solution:</b></p>
	<pre>
		<code>
function mutation(arr) {
  return arr[1].toLowerCase()
    .split('')
    .every(function(letter) {
      return arr[0].toLowerCase()
        .indexOf(letter) !== -1;
    });
}

mutation(["Mary", "Army"]);  //true
mutation(["Mary", "Aarmy"]);  //true
mutation(["hello", "neo"]);  //false
		</code>
	</pre>
	<p><b>Code Explanation: </b><br>Grab the second string, lowercase and turn it into an array; then make sure every one of its letters is a part of the lowercased first string. Every will basically give you letter by letter to compare, which we do by using indexOf on the first string. indexOf will give you -1 if the current letter is missing. We check that not to be the case, for if this happens even once every will be false.
	</p>
	<br>


	<figurecaption><h5>Falsy Bouncer:</h5>
		<p>Remove all falsy values from an array.<br>Falsy values in JavaScript are <b>false, null, 0, "", undefined, and NaN.</b></p>
	</figurecaption>
	<pre>
		<code>
function bouncer(arr) {

 return arr.filter(Boolean);
}

bouncer([7, "ate", "", false, 9]);  //[7, "ate", 9]
bouncer([false, null, 0, NaN, undefined, ""]);  //[]
bouncer([1, null, NaN, 2, undefined]);  //[1, 2]
		</code>
	</pre>
	<br>


	<figurecaption><h5>Seek and Destroy:</h5>
		<p>You will be provided with an initial array (the first argument in the destroyer function), followed by one or more arguments. Remove all elements from the initial array that are of the same value as these arguments.</p>
	</figurecaption>
	<pre>
		<code>
function destroyer(arr) {
  var args = Array.prototype.slice.call(arguments);

  for (var i = 0; i < arr.length; i++) {
    for (var j = 0; j < args.length; j++) {
      if (arr[i] === args[j]) {
        delete arr[i];
      }
    }
  }
  return arr.filter(Boolean);
}

destroyer([1, 2, 3, 1, 2, 3], 2, 3);  //[1, 1]
destroyer([1, 2, 3, 5, 1, 2, 3], 2, 3);  //[1, 5, 1]
destroyer([2, 3, 2, 3], 2, 3);  //[]
destroyer(["tree", "hamburger", 53], "tree", 53);  //["hamburger"]
		</code>
	</pre>
	<p><b>Code Explanation: </b>
	  <ul>
		<li>Create an array of arguments using Array.prototype.slice.call() and store it in the variable args. We’ll use this to check against arr.</li>
		<li>Start a basic for loop to iterate through arr. Nest another for loop inside the first, changing the integer variable j and arr to args. This second loop will iterate through args.</li>
		<li>Within the second loop create an if statement, checking strictly === that the current val of arr[i] is equal to args[j].</li>
		<li>If the value at the current index is equal in both arrays, use delete to remove it from arr.</li>
		<li>Outside of the nested loops: return the modified array using the Boolean object as a filter for any null's created by the delete operator.</li>
	  </ul>
	</p>
	<br>


	<p><b>+ solution:</b></p>
	<pre>
		<code>
function destroyer(arr) {
  var args = Array.from(arguments).slice(1);
  return arr.filter(function(val) {
    return !args.includes(val);
  });
}

destroyer([1, 2, 3, 1, 2, 3], 2, 3);  //[1, 1]
destroyer([1, 2, 3, 5, 1, 2, 3], 2, 3);  //[1, 5, 1]
destroyer([2, 3, 2, 3], 2, 3);  //[]
		</code>
	</pre>
	<p><b>Code Explanation: </b><br>
		<ul>
			<li>Declare a variable named args and set it equal to a new Array object from() the arguments passed into the function. On the same or next line, use the slice() method on args starting from the second index, 1. This separates the arguments used for filtering into their own array of args.</li>
			<li>Return the filtered array, using includes() in the callback function to check if val is not in args; returning true to keep the value in the original array or false to remove it.</li>
		</ul>
	</p>
	<br>


	<figurecaption><h5>Where do I belong:</h5>
		<p>Return the lowest index at which a value (second argument) should be inserted into an array (first argument) once it has been sorted. The returned value should be a number.<br>For example, getIndexToIns([1,2,3,4], 1.5) should return 1 because it is greater than 1 (index 0), but less than 2 (index 1).<br>Likewise, getIndexToIns([20,3,5], 19) should return 2 because once the array has been sorted it will look like [3,5,20] and 19 is less than 20 (index 2) and greater than 5 (index 1).</b></p>
	</figurecaption>
	<pre>
		<code>
function getIndexToIns(arr, num) {
  
    arr.push(num);
    
    arr.sort(function(a,b){
        return a-b;
    });
  
    return arr.indexOf(num);
}

getIndexToIns([40, 60], 50);  //1
getIndexToIns([10, 20, 30, 40, 50], 30);  //2
getIndexToIns([3, 10, 5], 3);  //0
getIndexToIns([2, 5, 10], 15);  //3
		</code>
	</pre>
	<p><b>Code Explanation: </b><br>
		<ul>
			<li>First we add the number num to the array using push() which adds it as the last element of the array.</li>
			<li>Then we use sort() with the callback function function(a, b){return a-b} to sort the numbers in ascending order.</li>
			<li>Lastly we return the postion or index of num in the array with the indexOf() function.</li>
		</ul>
	</p>
	<br>


	<figurecaption><h5>Ceasar's Cipher:</h5>
		<p>One of the simplest and most widely known ciphers is a Caesar cipher, also known as a shift cipher. In a shift cipher the meanings of the letters are shifted by some set amount.<br>A common modern use is the ROT13 cipher, where the values of the letters are shifted by 13 places. Thus 'A' ↔ 'N', 'B' ↔ 'O' and so on.<br>Write a function which takes a ROT13 encoded string as input and returns a decoded string.<br>All letters will be uppercase. Do not transform any non-alphabetic character (i.e. spaces, punctuation), but do pass them on.</p>
	</figurecaption>
	<pre>
		<code>
function rot13(str) {
  // Split str into a character array
  return str.split('')
  // Iterate over each character in the array
    .map.call(str, function(char) {
      // Convert char to a character code
      x = char.charCodeAt(0);
      // Checks if character lies between A-Z
      if (x < 65 || x > 90) {
        return String.fromCharCode(x);  // Return un-converted character
      }
      //N = ASCII 78, if the character code is less than 78, shift forward 13 places
      else if (x < 78) {
        return String.fromCharCode(x + 13);
      }
      // Otherwise shift the character 13 places backward
      return String.fromCharCode(x - 13);
    }).join('');  // Rejoin the array into a string
}

rot13("SERR PBQR PNZC");  //"FREE CODE CAMP"
rot13("SERR CVMMN!");  //"FREE PIZZA!"
rot13("GUR DHVPX OEBJA QBT WHZCRQ BIRE GUR YNML SBK.");  //"THE QUICK BROWN DOG JUMPED OVER THE LAZY FOX."
		</code>
	</pre>
	<br>


	<p><b>+ solution:</b></p>
	<pre>
		<code>
// Solution with Regular expression and Array of ASCII character codes
function rot13(str) {
  var rotCharArray = [];
  var regEx = /[A-Z]/ ;
  str = str.split("");
  for (var x in str) {
    if (regEx.test(str[x])) {
      // A more general approach
      // possible because of modular arithmetic
      // and cyclic nature of rot13 transform
      rotCharArray.push((str[x].charCodeAt() - 65 + 13) % 26 + 65);
    } else {
      rotCharArray.push(str[x].charCodeAt());
    }
  }
  str = String.fromCharCode.apply(String, rotCharArray);
  return str;
}
		</code>
	</pre>
	<p><b>Code Explanation: </b><br>
		<ul>
			<li>An empty array is created in a variable called <b>rotCharArray</b> to store the character codes.</li>
			<li>The <b>regEx</b> variable stores a regular expression for all uppercase letters from A to Z.</li>
			<li>We split <b>str</b> into a character array and then use a for loop to loop through each character in the array.</li>
			<li>Using an if statement, we test to see if the string only contains uppercase letters from A to Z.</li>
			<li>If it returns true, we use the <b>charCodeAt()</b> function and rot13 transformation to return the correct value, otherwise we return the initial value.</li>
			<li>We then return the string with the character codes from the <b>rotCharArray</b> variable.</li>
		</ul>
	</p>
	<br>


	<p><b>Algorithm Explanation:</b></p>
	<pre>
		<code>
ALPHA	KEY	BASE 	 	 	 ROTATED	ROT13
-------------------------------------------------------------
[A]     65  <=>   0 + 13  =>  13 % 26  <=>  13 + 65 = 78 [N]
[B]     66  <=>   1 + 13  =>  14 % 26  <=>  14 + 65 = 79 [O]
[C]     67  <=>   2 + 13  =>  15 % 26  <=>  15 + 65 = 80 [P]
[D]     68  <=>   3 + 13  =>  16 % 26  <=>  16 + 65 = 81 [Q]
[E]     69  <=>   4 + 13  =>  17 % 26  <=>  17 + 65 = 82 [R]
[F]     70  <=>   5 + 13  =>  18 % 26  <=>  18 + 65 = 83 [S]
[G]     71  <=>   6 + 13  =>  19 % 26  <=>  19 + 65 = 84 [T]
[H]     72  <=>   7 + 13  =>  20 % 26  <=>  20 + 65 = 85 [U]
[I]     73  <=>   8 + 13  =>  21 % 26  <=>  21 + 65 = 86 [V]
[J]     74  <=>   9 + 13  =>  22 % 26  <=>  22 + 65 = 87 [W]
[K]     75  <=>  10 + 13  =>  23 % 26  <=>  23 + 65 = 88 [X]
[L]     76  <=>  11 + 13  =>  24 % 26  <=>  24 + 65 = 89 [Y]
[M]     77  <=>  12 + 13  =>  25 % 26  <=>  25 + 65 = 90 [Z]
[N]     78  <=>  13 + 13  =>  26 % 26  <=>   0 + 65 = 65 [A]
[O]     79  <=>  14 + 13  =>  27 % 26  <=>   1 + 65 = 66 [B]
[P]     80  <=>  15 + 13  =>  28 % 26  <=>   2 + 65 = 67 [C]
[Q]     81  <=>  16 + 13  =>  29 % 26  <=>   3 + 65 = 68 [D]
[R]     82  <=>  17 + 13  =>  30 % 26  <=>   4 + 65 = 69 [E]
[S]     83  <=>  18 + 13  =>  31 % 26  <=>   5 + 65 = 70 [F]
[T]     84  <=>  19 + 13  =>  32 % 26  <=>   6 + 65 = 71 [G]
[U]     85  <=>  20 + 13  =>  33 % 26  <=>   7 + 65 = 72 [H]
[V]     86  <=>  21 + 13  =>  34 % 26  <=>   8 + 65 = 73 [I]
[W]     87  <=>  22 + 13  =>  35 % 26  <=>   9 + 65 = 74 [J]
[X]     88  <=>  23 + 13  =>  36 % 26  <=>  10 + 65 = 75 [K]
[Y]     89  <=>  24 + 13  =>  37 % 26  <=>  11 + 65 = 76 [L]
[Z]     90  <=>  25 + 13  =>  38 % 26  <=>  12 + 65 = 77 [M]
		</code>
	</pre>


	<p><b>+ solution:</b></p>
	<pre>
		<code>
function rot13(str) { // LBH QVQ VG!
  return str.replace(/[A-Z]/g, L => String.fromCharCode((L.charCodeAt(0) % 26) + 65));
}
		</code>
	</pre>
	<p><b>Code Explanation: </b><br>
		<ul>
			<li>Add here</li>
		</ul>
	</p>
	<br>


<h4>CODERBYTE "EASY" CHALLENGES SOLUTIONS:</h4>
<br>


	<figurecaption><h5>Longest Word</h5>
		<p>Return the logest word in a sentence, ignore punctuation. To do list:
			<ol>
				<li>Strip away any punctuation because the challenge tells us to ignore these symbols, so the string "hello$%()" is actually just "hello"</li>
				<li>Separate the sentence into a list of words in order to easily retrieve words and their respective lengths</li>
				<li>Then loop through this list and compare the words to find the one with the longest length </li>
			</ol>
			We will be using <b>regular expression</b> functions in order to strip away punctuation and turn the string into a list of words. Regular expressions are patterns we define for the program to find in some text.
		</p>
	</figurecaption>
	<pre>
		<code>
function LongestWord(sen) { 

  var arr = sen.match(/[a-z0-9]+/gi);

  var sorted = arr.sort(function(a, b) {
    return b.length - a.length;
  });

  return sorted[0];
         
}
   
LongestWord("the $$$longest# word is coderbyte");                            
		</code>
	</pre>

	<p><b>Code Explanation: </b><br>
		<ul>
			<li>We use the regex match function which searches the string for the pattern and returns an array of strings it finds in our case the pattern we define below returns words with only the characters a through z and 0 through 9, stripping away punctuation, e.g. "hello$% ##all" becomes [hello, all]</li>
			<li>The array sort function takes a function as a parameter which is used to compare each element in the array to the next element in the array</li>
			<li>This array now contains all the words in the original string but in order from longest to shortest length so we simply return the first element</li>
		</ul>
	</p>
	<br>


	<figurecaption><h5>Letter Changes:</h5>
		<p>
		  <ol>
			<li>Replace every letter in the string with the letter following it in the alphabet (ie. c becomes d, z becomes a).</li>
			<li>Then capitalize every vowel in this new string (a, e, i, o, u) and finally return this modified string.</li>
		  </ol>
		</p>
	</figurecaption>
	<pre>
		<code>
function LetterChanges(str) { 

return str.split('')
.map.call(str, function(char){
	x = char.charCodeAt(0);

	if (x < 122 && x >= 97){
		return String.fromCharCode(x +1); //moves one letter down, a = b
	}else if (x === 122){
		return String.fromCharCode(x = 97);  //z is a 
	}else {
		return String.fromCharCode(x); //non a-z characters stays the same
	}
}).join('').replace(/[aeiou]/g, function(c){ //wil capitalize [aeiou]
        return c.toUpperCase();
    });;
         
}

console.log(LetterChanges("hello*3")); //"Ifmmp*3"
console.log(LetterChanges("fun times!"));  //"gvO Ujnft!"
console.log(LetterChanges("z!"));  //a!
console.log(LetterChanges("a!"));  //b!
console.log(LetterChanges("b!"));  //c!                           
		</code>
	</pre>
	<br>


	<figurecaption><h5>Simple Adding:</h5>
		<p>Add up all the numbers from 1 to num. For example: if the input is 4 then your program should return 10 because 1 + 2 + 3 + 4 = 10. For the test cases, the parameter num will be any number from 1 to 1000. 
		</p>
	</figurecaption>
	<pre>
		<code>
function SimpleAdding(num) { 

  for (a = 0; num >= 1; num--) { 
	a = num + a; 
 } 
	return a; 
} 

console.log(SimpleAdding(5));  //15   5+4+3+2+1 = 15
console.log(SimpleAdding(12));  //78
console.log(SimpleAdding(140)); //9870                     
		</code>
	</pre>
	<br>


	<figurecaption><h5>+ solution:</h5>
	</figurecaption>
	<pre>
		<code>
function SimpleAdding2(num) { 

  var answer = 0;

  // loop from 1 to num
  for (var i = 1; i <= num; i++) {
    answer = answer + i;
  } 
  return answer;    
}

console.log(SimpleAdding2(4));  //10   4+3+2+1 = 10                                                      
console.log(SimpleAdding2(12));  //78
console.log(SimpleAdding2(140));  //9870                    
		</code>
	</pre>
	<br>


	<figurecaption><h5>+ solution:</h5>
	</figurecaption>
	<pre>
		<code>
function SimpleAdding3(num) { 

  return (num*(num+1))/2;      
}

console.log(SimpleAdding3(4));  //10
console.log(SimpleAdding3(140));  //9870                   
		</code>
	</pre>
	<br>


	<figurecaption><h5>Letter Capitalize:</h5>
		<p>Take the str parameter being passed and capitalize the first letter of each word. Words will be separated by only one space. 
		</p>
	</figurecaption>
	<pre>
		<code>
function LetterCapitalize(str) { 

	str = str.split(' ');
  
  for (var i = 0; i < str.length; i++) {
    str[i] = str[i].charAt(0).toUpperCase() + str[i].slice(1); 
  }
  return str.join(" ");
}
  
console.log(LetterCapitalize("hello world")); //Hello World
console.log(LetterCapitalize("i ran there"));  //I Ran There                    
		</code>
	</pre>
	<br>


	<figurecaption><h5>+ solution:</h5>
		<p>need to check the regex</p>
	</figurecaption>
	<pre>
		<code>
function SimpleSymbols(str) { 

  var str = '=' + str + '=';  //just adding extra characters in front and at the end of the str

  for (var i = 0; i < str.length; i++) {
    
    if (str[i].match(/[a-z]/i) !== null) {

      if (str[i-1] !== '+' || str[i+1] !== '+') { 
        return false;
      }
    }
  }
  return true;
}

console.log(SimpleSymbols("+d+=3=+s+"));
console.log(SimpleSymbols("f++d+"));                  
		</code>
	</pre>
	<br>


	<figurecaption><h5>+ solution:</h5>
		<p>need to check the regex</p>
	</figurecaption>
	<pre>
		<code>
function SimpleSymbols2(str) { 

  if (/^[a-zA-Z]/.test(str) || /[a-zA-Z]$/.test(str)) {
      return false;
  }
  else if (/[^+][a-zA-Z]/.test(str) || /[a-zA-Z][^+]/.test(str)) {
      return false;
  }
  else {
   return true; 
  } 
       
}
console.log(SimpleSymbols2("+d+=3=+s+"));
console.log(SimpleSymbols2("f++d+"));                   
		</code>
	</pre>
	<br>


	<figurecaption><h5>Check Nums:</h5>
		<p>Check if num2 is bigger than num1, if so return true, otherwise false. If numbers are equal, return "-1".</p>
	</figurecaption>
	<pre>
		<code>
function CheckNums2(num1,num2) { 

  if (num1 == num2) {
     return "-1"; 
  }
  else {
    return (num2 > num1);  //true or false 
  }     
}
console.log(CheckNums2(3, 122));
console.log(CheckNums2(67, 67));                  
		</code>
	</pre>
	<br>


	<figurecaption><h5>Time Convert:</h5>
		<p>Convert minutes num to "hours : mins"</p>
	</figurecaption>
	<pre>
		<code>
function TimeConvert(num) { 
  var hours = Math.floor(num/60);
  var minutes = num % 60;
  var str = hours + ":" + minutes;
  return str;
}

console.log(TimeConvert(126));  //2:6
console.log(TimeConvert(45));	//0:45
console.log(TimeConvert(450));	//7:30                 
		</code>
	</pre>
	<br>


	<figurecaption><h5>+ improved style:</h5>
		<p>Added "0" if minutes < 10</p>
	</figurecaption>
	<pre>
		<code>
function TimeConvert(num) { 
  var hours = Math.floor(num/60);
  var minutes = num % 60;
  var str = hours + ":" + minutes;
   	if (minutes < 10){
  		return hours + ":" + "0" + minutes;
  	}else {
  return str;
 }
}

console.log(TimeConvert(126));  //2:06
console.log(TimeConvert(45));	//0:45
console.log(TimeConvert(450));	//7:30
console.log(TimeConvert(850));	//14:10  
console.log(TimeConvert(7));	//0:07              
		</code>
	</pre>
	<br>


	<figurecaption><h5>Alphabet Soup:</h5>
		<p>Sort a string alphabetically.</p>
	</figurecaption>
	<pre>
		<code>
function AlphabetSoup(str) { 

	return str.split('').sort().join('');
	//convert str to array, sort, convert back to string
}
console.log(AlphabetSoup("coderbyte"));  //"bcdeeorty"
console.log(AlphabetSoup("hooplah"));  //"ahhloop"            
		</code>
	</pre>
	<br>


	<figurecaption><h5>Remove set of characters from a string:</h5>
		<p> You are given an array of characters and a string. Write a function to return the string with all the characters of the array removed.</p>
	</figurecaption>
	<pre>
		<code>
function removeChars(arr, string) {

	var newArray = [];

	string = string.split('');

//remove array elements from a string array:
  for (var i = 0; i < string.length; i++){
	if (arr.indexOf(string[i]) === -1){
		newArray.push(string[i]);
	}
  }
  return newArray.join('');
}

console.log(removeChars(['h', 'e', 'w', 'o'], "hello world"));   // "ll rld"            
		</code>
	</pre>
	<br>


	<figurecaption><h5>Check if valid number of parenthesis:</h5>
		<p> You are given a string with the symbols ( and ) and you need to write a function that will determine if the parenthsis are correctly nested in the string which means every opening ( has a closing )</p>
	</figurecaption>
	<pre>
		<code>
function matchingParens(string) {
  let counter = 0;
for (let c of string) {
if (c === '(') { counter += 1; } 
if (c === ')') { counter -= 1; }
}
return (counter === 0) ? true : false; }

console.log(matchingParens("()()())"));  //false
console.log(matchingParens("((()()))"));  //true
console.log(matchingParens("()"));  //true
console.log(matchingParens("(((("));  //false           
		</code>
	</pre>
	<p><b>Code Explanation:</b><br>
		<p>The first thing to notice is that it doesn’t matter how many parenthesis we actually have, what matters is that every single opening parenthsis “(“ at some point has a closing parenthesis “).” What we can do to solve this challenge is to maintain a counter and every single time we encounter an opening symbol we add 1 to it. Then every time we encounter a closing symbol we remove 1. If all opening symbols have a matching symbol at some point in the string, the end result of the counter should be 0. If it is more or less we’ll know that all parenthesis aren’t properly matched. You can see that for the first 4 examples above, if we maintain a counter we will end up at 0 once we reach the end of the string.</p>
	</p>
	<br>


	<figurecaption><h5>Count words that have at least 3 continuous vowels:</h5>
		<p>Loop through the string and maintain a counter. We are going to use a regular expression (regex) to count the vowels in a word and determine whether they are continuous. The solution below splits the string into an array of words and then loops through that array applying a regex search on each word. A regex search words by trying to find a search pattern within a string. The search pattern we will be using is to search for a set of characters, the vowels in this case, and check whether at least 3 of them occur next to each other.</p>
	</figurecaption>
	<pre>
		<code>
function threeVowels(string) {
// split string into array of words
let arr = string.split(' '); 
let count = 0;
// this is the pattern we will be searching for:
const pattern = /[aeiou]{3,}/gi;
// loop through array of words
 for (let word of arr) {
  if (word.match(pattern) !== null) {
  count += 1; }
  }
 return count; 
}
console.log(threeVowels("Naouitt"));  //1
console.log(threeVowels("Naoutt"));  //1
console.log(threeVowels("Naitt"));  //0
console.log(threeVowels("Naiiittuuaar"));  //1          
		</code>
	</pre>
	<br>



	<figurecaption><h5>First on-repeating character in a string:</h5>
		<p>Using <b>hash tables.</b>For this challenge you are given a string and you should return the first character that is unique in the entire string. For example, if string is “hello henry” then the first non-repeating character is the letter “o” because the first three characters in the string appear multiple times.</p>
	</figurecaption>
	<pre>
		<code>
function firstNonRep(string) { 
	let hashTable = {};
// store each character in the hash table with 
//the frequency of times it occurs
for (let c of string) {
  if (hashTable[c] === undefined) { 
	hashTable[c] = 1;
  } else { 
	hashTable[c] += 1;
  } 
}
// loop through string and return the first character 
// with a count of 1 in the hash table
for (let c of string) {
  if (hashTable[c] === 1) { 
  	return c;
  } 
}
// return -1 if no unique character exists
return -1; 
}

console.log(firstNonRep("hello henry")); //o 
console.log(firstNonRep("hellomi helom")); //i        
		</code>
	</pre>
		<p><b>Code Explanation:</b><br>
		We need to somehow store the letters and their frequencies in a data structure that’ll allow us to check how many times a specific character occurred. To solve this challenge, we’ll first loop through the string once and maintain a hash table that stores the count of each character. Then we’ll loop through the string again and return the first character we encounter that has a count of 1 in the hash table, meaning it occurs only once in the string. This algorithm will run in O(2n) because we are looping through the string twice, and this reduces to O(n) because we drop the constant, which is much faster than the nested loop algorithm.
	</p>













<h4>FREECODECAMP "INTERMEDIATE":</h4>
<br>


	<figurecaption><h5>Sum All Numbers in a Range:</h5>
		<p>We'll pass you an array of two numbers. Return the sum of those two numbers and all numbers between them. The lowest number will not always come first.</p>
	</figurecaption>
	<pre>
		<code>
function sumAll(arr) {
  var max = Math.max(arr[0], arr[1]);
  var min = Math.min(arr[0], arr[1]);
  var temp = 0;
  for (var i=min; i <= max; i++){
    temp += i;
   }
  return(temp);
}

sumAll([1, 4]);
		</code>
	</pre>
	<p><b>Code Explanation:</b><br>
		<ul>
			<li>First create a variable to store the max number between two.</li>
			<li>The same as before for the Smallest number.</li>
			<li>We create a temporary variable to add the numbers.</li>
			<li>Since the numbers might not be always in order, using max() and min() will help organize.</li>
		</ul>
	</p>
	<br>


	<figurecaption><h5>+ antother version::</h5>
	</figurecaption>
	<pre>
		<code>
function sumAll(arr) {
    var list = [];

    var lower = Math.min(arr[0], arr[1]);
    var upper = Math.max(arr[0], arr[1]);

    for (var i = lower; i <= upper; i++) {
        list.push(i);
    }
    var total = list.reduce(function(a, b) {
        return a + b;
    });
    console.log(total);
}

sumAll([1, 4]);
		</code>
	</pre>
	<br>


















<h4>FREECODECAMP "ADVANCED":</h4>
<br>

	<figurecaption><h5>Validate US Telephone Numbers: (my long version/efforts to solve)</h5>
		<p>Return true if the passed string is a valid US phone number. The user may fill out the form field any way they choose as long as it is a valid US number. The following are examples of valid formats for US numbers (refer to the tests below for other variants):
	</figurecaption>
	<pre>
		<code>
555-555-5555
(555)555-5555
(555) 555-5555
555 555 5555
5555555555
1 555 555 5555
		</code>
	</pre>
For this challenge you will be presented with a string such as 800-692-7753 or 8oo-six427676;laskdjf. Your job is to validate or reject the US phone number based on any combination of the formats provided above. The area code is required. If the country code is provided, you must confirm that the country code is 1. Return true if the string is a valid US phone number; otherwise return false.</p>
	</figurecaption>
	<pre>
		<code>
function telephoneCheck(str) {

	var arr = str.split('');

var number1 = parseInt(arr[0]);  //convets string to a number "1" to 1 (integer)

var allowed = /(\(|\))|\d|\-|\s/gi;  //parenthesis, numbers, hyphen, space ALLOWED

var regExp2 = /(\(|\))/gi;   //both parenthesis 

var regExp3 = /[^0-9]/gi; //only numbers 

//clean up the " " empty array elements object function:
Array.prototype.clean = function(deleteValue) {
  for (var i = 0; i < this.length; i++) {
    if (this[i] == deleteValue) {         
      this.splice(i, 1);
      i--;
    }
  }
  return this;
};

if (arr[0] === "(" ||  Number.isInteger(number1)){  //starts with ( or number 
	//console.log("valid number so far");
	if (str.match(allowed).length === arr.length){  
	//filters anything that is other that parenthesis, numbers, hyphen or space 
	//if lengths don't match, it means arr has not allowed charcters, which makes it false
	//console.log("allowed");
		arr.clean(" ");  //using func above, clean up arr from " "
		//console.log(arr);
	  if (arr[0] === "(" && arr[4] === ")" || arr[1] === "(" && arr[5] === ")" || str.match(regExp2) == null){  
		 //if have both parenthesis at indexes [0] && [4} or [1] && [5] or none
		 	//console.log("has both parenthesis or none");
		var matches = str.replace(regExp3, '');  //all non-numbers replace with '' nothing
		//console.log(matches.length);
		  if (matches.length === 10 || matches.length === 11 && matches[0] == 1){
		 		console.log(true);
		  }else {
		 		console.log(false);
		  }
	  }else {
		console.log(false);
	  }
	}else {
	  console.log(false);
	}	
}else {
	console.log(false);
}

}   

telephoneCheck("555-555-5555"); //true
telephoneCheck("1 555-555-5555"); //true
telephoneCheck("1 (555) 555-5555");  //true  //both parenthesis
telephoneCheck("5555555555");  //true
telephoneCheck("(555)555-5555");  //true  //both parenthesis   0, 4 valid parenthesis position
telephoneCheck("1(555)555-5555"); //true  //both parenthesis   1, 5 valid parenthesis position 

telephoneCheck("555-5555");  //false
telephoneCheck("5555555"); //false
telephoneCheck("1 555)555-5555"); //false  !!! sorted 

telephoneCheck("1 555 555 5555"); //true
telephoneCheck("1 456 789 4444"); //true

telephoneCheck("123**&!!asdf#"); //false
telephoneCheck("55555555"); //false
telephoneCheck("2 757 622-7382"); //false    !!! sorted
telephoneCheck("10 (757) 622-7382"); //false  //both parenthesis

telephoneCheck("(555)5(55?)-5555"); //false !!!  //both parenthesis
telephoneCheck("(555-555-5555"); //false  !!!
telephoneCheck("555)-555-5555");  //false !!!
telephoneCheck("-1 (757) 622-7382");  //false !!!

telephoneCheck("(6505552368)"); //false !!! tricky one       
		</code>
	</pre>
	<br>


	<figurecaption><h5>+ original solution:</h5>
	</figurecaption>
	<pre>
		<code>
function telephoneCheck(str) {
   var regex = /^(1\s?)?(\(\d{3}\)|\d{3})[\s\-]?\d{3}[\s\-]?\d{4}$/;
   return regex.test(str);
}

telephoneCheck("555-555-5555"); //true
telephoneCheck("1 555-555-5555"); //true
telephoneCheck("555)-555-5555");  //false 
telephoneCheck("-1 (757) 622-7382");  //false             
		</code>
	</pre>
		<p><b>Code Explanation:</b><br>
		<ul>
			<li><b>^</b> denotes the beginning of the string <b>(1\s?)?</b> checks allows for a “1” or a "1 " at the beginning.</li>
			<li><b>\d{n}</b> checks for exactly n number of digits so <b>(\(\d{3}\)|\d{3})</b> checks for three digits that are allowed to be between parenthesis.</li>
			<li><b>[\s\-]?</b> checks for spaces or dashes between the groups of digits.</li>
			<li><b>$</b> denotes the end of the string. In this case the beginning and end of the string are used in the regex to prevent it from matching any longer string that might contain a valid phone number (eg. “s 555 555 5555 a”).</li>
			<li>Lastly we use <b>regex.test(str)</b> to test if the string adheres to the regular expression and return <b>true</b> or <b>false.</b></li>
		</ul>
	</p>
	<br>


	<figurecaption><h5>DELI COUNTER <b>RUBY</b> version:</h5>
	</figurecaption>
	<pre>
		<code>
def line(deli)
  if deli.empty?
    puts "The line is currently empty."
  else
    current_line = "The line is currently:"
    deli.each.with_index(1) do |person, i|
      current_line << " #{i}. #{person}"
    end
    puts current_line
  end
end

def take_a_number(deli, name)
  deli << name
  puts "Welcome, #{name}. You are number #{deli.length} in line."
end

def now_serving(deli)
  if deli.empty?
    puts "There is nobody waiting to be served!"
  else
    puts "Currently serving #{deli.first}."
    deli.shift
  end
end

take_a_number(katz_deli, "Grace")   #Welcome, Grace. You are number 1 in line.
take_a_number(katz_deli, "Edgar")   #Welcome, Edgar. You are number 2 in line.
take_a_number(katz_deli, "Ada")     #Welcome, Ada. You are number 3 in line.
line(katz_deli)     #The line is currently: 1. Grace 2. Edgar 3. Ada

now_serving(katz_deli)   #Currently serving Grace
line(katz_deli)          #The line is currently: 1. Edgar 2. Ada
take_a_number(katz_deli, "Mimi")   #Welcome, Mimi. You are number 3 in line.

now_serving(katz_deli)   #Currently serving Edgar
now_serving(katz_deli)   #Currently serving Ada
line(katz_deli)       #The line is currently: 1. Mimi

now_serving(katz_deli)   #Currently serving Mimi
line(katz_deli)       #The line is currently empty.
		</code>
	</pre>
	<br>


	<figurecaption><h5>OXFORD COMMA <b>RUBY</b> LAB:</h5>
	</figurecaption>
	<pre>
		<code>
def oxford_comma(array)
  if array.size == 1
    str = array.join    #simply converts one element to string
    puts str
  elsif array.size == 2
    str = array.join " and "  #joins 2 elements with "and"
    puts str
  else  
    last_element = array.pop   #takes the last element off
    #puts last_element
    str = array.insert(-1, "and ")   #inserts "and " at the end of an array
    str = str.join ", "   #converts to a string with ","
    str += last_element  #adds the last element to the end 
    puts str
  end
end

oxford_comma(["fiddleheads","okra","kohlrabi"])  #fiddleheads, okra, and kohlrabi
oxford_comma(["kiwi", "durian"])  #kiwi and durian 
oxford_comma(["kiwi"])   #kiwi 
		</code>
	</pre>
	<br>


	<figurecaption><h5>REVERSE A STRING USING EACH VS COLLECT <b>RUBY</b> LAB:</h5>
	</figurecaption>
	<pre>
		<code>
#EACH:
def reverse_each_word(str)
  str = str.split 
  new_str = []
  str.each do |word|
    word = word.reverse 
    new_str << word
  end
  new_str.join " "
end 

#COLLECT:

def reverse_each_word(sentence)
  sentence.split.collect {|word| word.reverse}.join(" ")
end

reverse_each_word("Hello, how are you?")  #,olleH woh era ?uoy
		</code>
	</pre>
	<br>


	<figurecaption><h5>EACH.WITH_INDEX <b>RUBY</b> LAB:</h5>
	</figurecaption>
	<pre>
		<code>
array = ["Doc", "Dopey", "Bashful", "Grumpy"]

def roll_call_dwarves(array_of_dwarves)
  list_of_dwarves = []
  array_of_dwarves.each.with_index(1) do |dwarf, i|
    list_of_dwarves << "#{i}. #{dwarf}"
  end 
  print list_of_dwarves
end

roll_call_dwarves(array)   #["1. Doc", "2. Dopey", "3. Bashful", "4. Grumpy"]
		</code>
	</pre>
	<br>


	<figurecaption><h5>MAP <b>RUBY</b> LAB:</h5>
	</figurecaption>
	<pre>
		<code>
planeteer_calls = ["earth", "wind", "fire", "water", "heart"]

def summon_captain_planet(planeteers)
  planeteers.map do |planeteer|
    planeteer = planeteer.capitalize + "!"
  end
end

print summon_captain_planet(planeteer_calls)  #["Earth!", "Wind!", "Fire!", "Water!", "Heart!"]
		</code>
	</pre>
	<br>


	<figurecaption><h5>ANY? <b>RUBY</b> LAB:</h5>
	</figurecaption>
	<pre>
		<code>
def long_planeteer_calls(calls)
  calls.any? do |call|
    call.size > 4   #or length 
  end
end

short_words = ["puff", "go", "two"]
puts long_planeteer_calls(short_words)
#=> false
 
assorted_words = ["two", "go", "industrious", "bop"]
puts long_planeteer_calls(assorted_words)
#=> true
		</code>
	</pre>
	<br>


	<figurecaption><h5>INCLUDE? <b>RUBY</b> LAB:</h5>
	</figurecaption>
	<pre>
		<code>
def find_the_cheese(array)
  cheese_types = ["cheddar", "gouda", "camembert"]
  cheese_types.map do |cheese|
  if array.include?(cheese)
    return cheese
  else 
    return "it does not contain cheese!"
  end
 end
end

snacks = ["crackers", "gouda", "thyme"]
puts find_the_cheese(snacks)
#=> "gouda"

soup = ["tomato soup", "cheddar", "oyster crackers", "gouda"]
puts find_the_cheese(soup)
#=> "cheddar"

ingredients = ["garlic", "rosemary", "bread"]
puts find_the_cheese(ingredients)
#=> nil
		</code>
	</pre>
	<br>


	<figurecaption><h5>YIELD AND BLOCKS <b>RUBY</b> LAB:</h5>
	</figurecaption>
	<pre>
		<code>
def hello_t(array)
  if block_given?
    i = 0 
  
    while i < array.size 
    yield array[i]
    i += 1 
   end
  array
  else 
  puts "Hey! No block was given!"
end
end

hello_t(["Tim", "Tom", "Jim"])   #Hey! No block was given!

hello_t(["Tim", "Tom", "Jim"]) do |name|
  if name.start_with?("T")
    puts "Hi, #{name}"    #Hi, Tim     Hi, Tom 
  end
end
		</code>
	</pre>
		<p><b>Code Explanation:</b><br>
We built our own implementation of the <b>#eachmethod</b>. We used <b>while</b> to iterate through each element of the array and passed, or yielded, each successive element to an accompanying block. That block used a parameter placeholder, <b>|name|</b>, to set a variable, <b>name</b>, equal to whatever value is yielded into the block at each step of the iteration. That block also contained code to execute with each yielded element in turn.
	</p>
	<br>


	<figurecaption><h5>HOW YIELD WORKS: <b>RUBY</b> LAB:</h5>
	</figurecaption>
	<pre>
		<code>
def my_method
  puts "reached the top"
  yield
  puts "reached the bottom"
end

my_method do
  puts "reached yield"
end

reached the top
reached yield
reached the bottom
 => nil
		</code>
	</pre>
		<p><b>Code Explanation:</b><br>
Passing blocks to methods
A method doesn’t need to specify the block in it’s signature in order to receive a block parameter. You can just pass a block to any function but unless that function calls <b>yield</b>, the block won’t get executed.

On the other hand, if you do call <b>yield</b> in your method, then the block parameter becomes mandatory and the method will raise an exception if it doesn’t receive a block.

If you want to make the block an optional parameter, you can use the <b>block_given?</b> method which will return either true or false depending on if a block was passed in to the method or not.
	</p>
	<br>


	<figurecaption><h5>MY_EACH METHOD (BUILT W YIELD): <b>RUBY</b> LAB:</h5>
	</figurecaption>
	<pre>
		<code>
def hello_t(array)
  if block_given?
    i = 0 
  
    while i < array.size 
    yield array[i]
    i += 1 
   end
  array
  else 
  puts "Hey! No block was given!"
end
end

hello_t(["Tim", "Tom", "Jim"])   #Hey! No block was given!

hello_t(["Tim", "Tom", "Jim"]) do |name|
  if name.start_with?("T")
    puts "Hi, #{name}"    #Hi, Tim     Hi, Tom 
  end
end

#short version:

def my_each(array)
  i = 0 
  while i < array.size 
  yield array[i]
  i += 1 
end 
  array
end
		</code>
	</pre>
	<br>


	<figurecaption><h5>MY_SELECT METHOD (manual, w YIELD): <b>RUBY</b> LAB:</h5>
	</figurecaption>
	<pre>
		<code>
def my_select(array)
  i = 0
  select = []
  while i < array.length
    if yield(array[i])
      select << array[i]
    end
    i+=1
  end
  print select
end

array_nums = [3, 6, 7, 8, 9]
my_select(array_nums) do |num|
  num.even?      #[6, 8]
end 
#same as:
my_select(array_nums) {|num| num.odd? }     #[3, 7, 9]
		</code>
	</pre>
	<br>


	<figurecaption><h5>#SORT EXPLAINED: <b>RUBY</b> LAB:</h5>
	</figurecaption>
	<pre>
		<code>
array = [7, 3, 1, 2, 6, 5]
 
print array.sort do |a, b|
  if a == b
    0
  elsif a < b
    -1
  elsif a > b
    1
  end
end
#  => [1, 2, 3, 5, 6, 7]


#ascending order:
array = [7, 3, 1, 2, 6, 5]
print array.sort { |a, b| a <=> b }
#  => [1, 2, 3, 5, 6, 7]


#descending order:
array = [7, 3, 1, 2, 6, 5]
puts array.sort { |a, b| b <=> a }   #[7, 6, 5, 3, 2, 1]
#  => [1, 2, 3, 5, 6, 7] 


#descending:
dishes = ["steak", "apple pie", "vegetable soup"]
print dishes.sort { |a, b| b <=> a }
# => [vegetable soup", "steak", "apple pie"]


#ascending:
dishes = ["steak", "apple pie", "vegetable soup"]
print dishes.sort
		</code>
	</pre>



	<figurecaption><h5>#if all elements in an array starts w "r", return true: <b>RUBY</b> LAB:</h5>
	</figurecaption>
	<pre>
		<code>
def begins_with_r(array)
  true_array = []
  array.collect do |name|
  if name.start_with?("r")
    true_array << name
  end 
end 
print true_array == array
end

begins_with_r(["ruby", "rspec", "rails"])  #true
begins_with_r(["ruby", "cat", "rails"])   #false 


#OR:

def begins_with_r(array)
  flag = true
  array.each do |element|
    flag = false if element[0] != "r"
  end
  flag
end
		</code>
	</pre>
	<br>


	<figurecaption><h5>#return a new array with all elements from an array that contains "a": <b>RUBY</b> LAB:</h5>
	</figurecaption>
	<pre>
		<code>
def contain_a(array)
  cont_a = []
  array.collect do |word|
    if word.include?("a")
      cont_a << word
    end
  end 
  print cont_a
end

contain_a(["earth", "fire", "wind", "water", "heart"])   #["earth", "water", "heart"]

#OR:

def contain_a(array)
  container = []
  array.each do |element|
    container << element if element.include?("a")
  end
  container
end
		</code>
	</pre>
	<br>



	<figurecaption><h5>#remove everything that's not a string in an array: <b>RUBY</b> LAB:</h5>
	</figurecaption>
	<pre>
		<code>
def remove_non_strings(array)
  strings_only = []
  array.collect do |element|
    if element.class == String
      strings_only << element
    end 
  end 
  print strings_only
end

remove_non_strings(["blake", 1, :hello])   #["blake"]

#OR:

def remove_non_strings(array)
  container = []
  array.each do |element|
    container << element if element.is_a?(String)
  end
  container
end
		</code>
	</pre>
	<br>


	<figurecaption><h5>#returns the first element that begins w letters "wa": <b>RUBY</b> LAB:</h5>
	</figurecaption>
	<pre>
		<code>
def first_wa(array)
  start_wa = []
  array.collect do |word|
    if word.class == String && word.start_with?("wa")
        start_wa << word 
    end
  end
  puts start_wa.first 
end

first_wa(["candy", :pepper, "wall", :ball, "wacky"])   #wall

#OR:

def first_wa(array)
  first_wa = nil
  array.each do |element|
    if element.match(/wa/)
      first_wa = element 
      break
    end
  end
  first_wa
end
		</code>
	</pre>
	<br>


	<figurecaption><h5>#combines two nested data structures into one: <b>RUBY</b> LAB:</h5>
	</figurecaption>
	<pre>
		<code>
def merge_data(keys, values)
  container = []
  keys.each do |person_name|
    name = person_name[:first_name]
    values.each do |person_data|
      if person_data[name]
        merged_person = person_data[name]
        merged_person[:first_name] = name
        container << merged_person
      end
    end
  end
  container
end

puts merge_data([{:first_name => "blake"},{:first_name => "ashley"}], 
  [{"blake" => {:awesomeness => 10, :height => "74", :last_name => "johnson"},
"ashley" => {:awesomeness => 9, :height => 60, :last_name => "dubs"}}])

#desired output:
[{:first_name=>"blake", :awesomeness=>10, :height=>"74", :last_name=>"johnson"},
  {:first_name=>"ashley", :awesomeness=>9, :height=>60, :last_name=>"dubs"}]
		</code>
	</pre>
	<br>


	<figurecaption><h5>#count how many times smth appears in an array: <b>RUBY</b> LAB:</h5>
	</figurecaption>
	<pre>
		<code>
def count_elements(array)
  array.each do |original_hash|
    original_hash[:count] = 0
    name = original_hash[:name]
    array.each do |hash|
      if hash[:name] == name
        original_hash[:count] += 1
      end
    end
  end.uniq    #eliminates repeats. otherwise would print obj for blake twice 
end

puts count_elements([{:name => "blake"}, {:name => "blake"}, {:name => "ashley"}])

#output:
#[{:name => "blake", :count => 2}, {:name => "ashley", :count => 1}])
		</code>
	</pre>
	<br>


	<figurecaption><h5>#find all cool hashes: <b>RUBY</b> LAB:</h5>
	</figurecaption>
	<pre>
		<code>
def find_cool(array)
  container = []
  array.each do |element|
    if element[:temperature] == "cool" 
      container << element
    end
  end
  container
end

puts find_cool([{:name => "ashley", :temperature => "sort of cool"},
{:name => "blake", :temperature => "cool"}])

#OUTPUT: 
#find_cool([{:name => "blake",:temperature => "cool"}])
		</code>
	</pre>
	<br>


	<figurecaption><h5>#organizes the schools by location: <b>RUBY</b> LAB:</h5>
	</figurecaption>
	<pre>
		<code>
def organize_schools(schools)
  organized_schools = {}
  schools.each do |name, location_hash|
    location = location_hash[:location]  #no implicit conversion of Symbol into Integer (TypeError)
    if organized_schools[location]
      organized_schools[location] << name
    else
      organized_schools[location] = []
      organized_schools[location] << name
    end
  end
  organized_schools
end 

puts organize_schools({
    
      "flatiron school bk" => {
        :location => "NYC"
      },
      "flatiron school" => {
        :location => "NYC"
      },
      "dev boot camp" => {
        :location => "SF"
      },
      "dev boot camp chicago" => {
        :location => "Chicago"
      },
      "general assembly" => {
        :location => "NYC"
      },
      "Hack Reactor" => {
        :location => "SF"
      }
    }
  )

#EXPECTED output:
organize_schools({
  "NYC"=>["flatiron school bk", "flatiron school", "general assembly"], 
  "SF"=>["dev boot camp", "Hack Reactor"], 
  "Chicago"=>["dev boot camp chicago"]
})
		</code>
	</pre>
	<br>












</figure>

</div>

<!--SCRIPT LINKS END OF BODY-->  
    
<!--4.jQuery-->
<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>

<!-- for draggable: -->
<!-- <script src="https://code.jquery.com/ui/1.12.1/jquery-ui.js"></script> -->
    
<!-- JAVASCRIPT -->
<script src="script.js"></script>

<!--5.this one for TETHER.IO-->
<script src="https://npmcdn.com/tether@1.2.4/dist/js/tether.min.js"></script>
    
<!--6.JS for BOOTSTRAP-->
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0-alpha.6/js/bootstrap.min.js" integrity="sha384-vBWWzlZJ8ea9aCX4pEW3rVHjgjt7zpkNpZk+02D9phzyeVkE+jo0ieGizqPLForn" crossorigin="anonymous"></script>

</body>
</html>